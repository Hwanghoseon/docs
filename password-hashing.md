# 패스워드 암호화 기능

## 1. 개요: 패스워드 암호화 필요성

패스워드는 민감한 정보. 데이터베이스 유출 시 심각한 보안 사고를 방지하기 위해 반드시 암호화하여 저장

## 2. 암호화 방식 : 단방향 암호화 vs 양방향 암호화

| 구분             | 단방향 암호화 (Hashing)                                                                 | 양방향 암호화 (Encryption)                                                                    |
| :--------------- | :-------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------- |
| **개념**         | 원본 데이터를 암호화하지만, **복호화(원상 복구)가 불가능한** 방식                       | 암호화된 데이터를 **키(Key)를 이용하여 다시 원본 데이터로 되돌릴 수 있는(복호화 가능한)** 방식|
| **특징**         | - 단방향성: 복호화 불가<br>- 고정 길이 출력: 항상 동일 길이의 해시 값<br>- 결정론적: 동일 입력 시 항상 동일 해시 값<br>- 눈사태 효과: 작은 변화에도 해시 값 완전 다름<br>- 충돌 저항성: 동일 해시 값 생성 확률 극히 낮음 | - 복호화 가능: 키만 있으면 복원 가능<br>- 기밀성 보장: 데이터 숨김<br>- 두 방식: 대칭키(동일 키, 빠름), 비대칭키(다른 키 쌍, 느림, 키 교환/인증) |
| **장점**         | - **비밀번호 저장에 최적**: DB 유출 시 실제 비밀번호 보호<br>- 데이터 무결성 검증 (변조 확인)                   | - **원본 데이터 복구 필요 시 사용**<br>- 빠른 암복호화 (대칭키)<br>- 안전한 키 교환/인증 (비대칭키)                                                                                                                                                                                                                                                                                                                                                          |
| **단점**         | - 복호화 불가능: 원본 데이터 되돌릴 수 없음<br>- 암호화 속도: bcrypt 등은 의도적으로 느림                       | - **키(Key) 관리의 어려움/위험**<br>- 비밀번호 저장에 부적합 (키 유출 시 치명적)<br>- 느린 속도 (비대칭키)                                                                                                                                                                                                                                                                                                   |

## 3. 패스워드 암호화에 단방향 암호화(Hashing)를 더 많이 쓰는 이유

비밀번호를 저장하고 검증하는 데는 단방향 암호화(Hashing) 방식이 **압도적으로 많이 사용되며, 필수적인 방법**

*   **최고의 보안성**: 복호화가 불가능하다는 점이 가장 중요. 해커가 해시된 비밀번호를 가져가더라도 실제 비밀번호는 알아낼 수 없어 사용자의 개인정보를 강력하게 보호
*   **복원 불필요**: 시스템은 비밀번호 자체를 알 필요 없이, 단지 '입력된 비밀번호가 올바른지'만 검증. 해시 값 비교만으로 충분
*   **키 관리 위험 제거**: 양방향 암호화처럼 복호화 키를 관리할 필요가 없어 키 유출로 인한 대규모 비밀번호 노출 위험이 없음

## 4. SHA-256 기반 단방향 해싱 구현

비밀번호 암호화를 위해 **SHA-256** 알고리즘을 사용한 단방향 해싱 방식을 구현

### 4.1. SHA-256 이란?

*   **SHA-256 (Secure Hash Algorithm 256-bit)**은 SHA-2 계열에 속하는 단방향 해시 함수
*   어떤 길이의 입력 데이터를 받든 **항상 256비트 (64자리의 16진수 문자열) 길이의 고정된 해시 값**을 출력
*   **보안성**: 입력값의 작은 변화에도 해시 값이 완전히 달라지는 **'눈사태 효과'**와 서로 다른 입력이 동일 해시 값을 생성할 확률이 극히 낮은 **'충돌 저항성'**을 가짐

### 4.2. 구현된 SHA-256 해싱의 작동 원리

현재 구현된 방식은 `EncryptUtill` 클래스의 `encryptSHA` 메서드를 통해 이루어짐

1.  **고정 키(Pepper) 추가**: 사용자가 입력한 평문 비밀번호에 `PropertyConfig`에서 설정된 `shaKey` (예: `mySecretStaticKey_`)라는 **고정된 키(Pepper)**를 앞에 붙여서 사용 (예: `shaKey + 사용자입력비밀번호`)
2.  **SHA-256 해싱**: 이렇게 결합된 문자열을 SHA-256 알고리즘을 사용하여 해싱
3.  **해시 값 저장**: 생성된 256비트 해시 값(16진수 64자리 문자열)이 데이터베이스의 `empPwd` 컬럼에 저장

## 5. 민감 정보(주민등록번호 등) 양방향 암호화

비밀번호와는 달리, **원본 데이터의 복원이 반드시 필요한 민감 정보** (예: 주민등록번호, 계좌번호, 이메일 주소, 신용카드 번호 등)는 양방향 암호화를 사용

### 5.1. 개요: 양방향 암호화의 필요성

*   **목표**: 데이터의 **기밀성** (Confidentiality) 보장. 허가되지 않은 사용자나 시스템으로부터 데이터를 보호
*   **활용**: 시스템이 사용자의 주민등록번호를 확인하거나, 특정 결제를 위해 신용카드 번호를 읽어야 하는 경우 등에 사용

### 5.2. 대표적인 양방향 암호화 방식: AES-256

*   **AES (Advanced Encryption Standard)**는 미국 표준 기술 연구소(NIST)에 의해 채택된 대칭키 암호화 알고리즘으로, 전 세계적으로 가장 널리 사용되고 안전하다고 평가받는 표준 암호화 방식
*   **AES-256**: 256비트의 암호화 키를 사용하여 데이터를 암호화/복호화. 키 길이가 길수록 더 강력한 보안 강도를 가짐
*   **작동 원리**:
    *   **대칭키 암호화**: 암호화와 복호화에 **동일한 키**를 사용. 이 키가 안전하게 관리되는 것이 보안의 핵심
    *   **초기화 벡터 (Initialization Vector, IV)**: 동일한 평문이 암호화될 때 항상 동일한 암호문이 생성되는 것을 방지하기 위해 사용되는 무작위 값. IV는 암호문과 함께 저장되거나 전송되어야 하며, 매 암호화마다 새로 생성하는 것이 보안상 권장
    *   원본 데이터(평문)를 AES 키와 IV를 사용하여 암호화하고, 암호화된 데이터(암호문)를 동일한 AES 키와 IV를 사용하여 원본 데이터로 복호화
    *   AES 키는 데이터를 어떻게 변형시킬지 본질적인 알고리즘 로직을 담고 있는 절대적인 비밀 정보
    *   IV는 암호화 시작점의 무작위성을 보장하여, 같은 평문이 항상 같은 암호문이 되는 것을 방지하고, CBC 모드에서는 암호문 블록 간의 체인 연결을 시작하는 역할

### 5.3. 구현 예시: AES-256 기반 양방향 암호화

`EncryptUtil` 클래스에 `encryptAES` 및 `decryptAES` 메서드를 추가하여 구현. 실제 구현 코드는 프로젝트 환경과 사용 언어에 따라 달라질 수 있으나, 일반적으로 다음과 같은 요소를 포함.

*   **주요 고려사항**:
    *   **키(AES_KEY_STRING)와 IV(AES_IV_STRING)의 길이**: AES-256은 32바이트 키를 사용하고, IV는 블록 크기와 동일하게 16바이트(128비트)를 사용
    *   **초기화 벡터 (IV) 관리**: 실제로는 보안 강화를 위해 매번 다른 IV를 생성하고 암호문과 함께 저장하는 것이 권장 (예: 암호문 앞에 IV를 붙여서 저장)
    *   **패딩 (Padding)**: 블록 암호는 데이터를 특정 블록 크기 단위로 처리하므로, 데이터가 블록 크기에 맞지 않을 경우 패딩 규칙(예: `PKCS5Padding`)에 따라 데이터를 채워줌

### 5.4. 키(Key) 관리의 중요성 및 주의사항

양방향 암호화에서 가장 중요하고 민감한 부분이 바로 **암호화 키의 관리**. 키가 유출되면 암호화된 모든 데이터가 복호화될 위험에 처하기 때문에, 키의 생성부터 보관, 사용, 폐기에 이르는 전 과정이 철저하게 관리되어야 함

*   **안전한 키 보관 장소**:
    *   **환경 변수**: 애플리케이션 코드에 직접 키를 하드코딩하는 대신, 서버의 환경 변수에 저장하여 코드와 키를 분리
    *   **외부 설정 파일/Secret 관리**: 키를 외부에 안전하게 저장된 설정 파일(예: 암호화된 설정 파일)이나 Kubernetes Secrets, Docker Secrets 등과 같은 Secret 관리 도구를 통해 관리
    *   **키 관리 시스템 (KMS)**: AWS KMS, Azure Key Vault, Google Cloud KMS와 같은 클라우드 기반 KMS를 활용하는 것이 가장 안전하고 권장되는 방법. KMS는 키 생성, 저장, 사용 및 접근 제어를 중앙에서 관리하여 보안성을 극대화
    *   **하드웨어 보안 모듈 (HSM)**: 물리적인 장치를 이용하여 키를 생성하고 보관. 최고 수준의 보안 및 규정 준수가 필요할 때 사용
*   **키 사용 시 주의사항**:
    *   **키 노출 방지**: 로그, 에러 메시지, 개발자 도구 등 어떠한 곳에도 키가 노출되지 않도록 각별히 주의
    *   **접근 제어**: 키에 대한 접근은 최소한의 권한을 가진 사용자나 서비스에게만 허용되어야 함 (최소 권한 원칙)
    *   **키 교체(Rotation)**: 주기적으로 (예: 매년 또는 격월) 암호화 키를 변경(교체)하여 보안을 강화하는 것이 좋음. 키가 유출되었을 때의 피해 범위를 줄이고, 장기간 동일 키 사용으로 인한 위험을 낮출 수 있음. 키를 교체할 때는 기존 키로 암호화된 데이터를 새 키로 다시 암호화하는 과정이 필요할 수 있음
*   **보안 코딩 관행**:
    *   데이터 암복호화 시 사용되는 라이브러리/프레임워크의 권장 보안 가이드를 따르고, 최신 보안 패치가 적용된 버전을 사용
